Auth Service Overview & Debugging Guide
This document provides a detailed explanation of the auth-service architecture to help you understand how it works and debug issues effectively.

1. High-Level Architecture
The auth-service is a Node.js microservice built with Express.js. It handles user authentication and authorization using JWT (JSON Web Tokens) and stores data in MongoDB.

Key Technologies
Runtime: Node.js
Framework: Express.js
Database: MongoDB (using Mongoose ODM)
Authentication: JWT (Access Tokens + Refresh Tokens)
Security: Helmet, CORS, Bcrypt (password hashing)
Documentation: Swagger UI
2. Project Structure & Flow
Here is how the request flows through the application:

Entry Point: 
src/server.js
This is the file that starts the application.
It first connects to MongoDB using 
connectDB()
.
Critical for Debugging: If the DB connection fails here (as seen in your logs), the server will not start.
Once connected, it starts listening on the port defined in 
.env
 (default: 3002).
App Configuration: 
    src/app.js
    Sets up the Express application.
Middleware:
  helmet(): Adds security headers.
  cors(): Allows requests from other domains (e.g., frontend).
  express.json(): Parses incoming JSON request bodies.
  Routes: Mounts authentication routes at /api/v1/auth.
  Swagger: Serves API documentation at /api-docs.

Database Connection: 
    src/config/db.js
    Handles the connection to MongoDB Atlas.
    Uses mongoose.connect(env.MONGO_URI).
    Current Issue: The error MongooseServerSelectionError happens here because the MongoDB driver cannot reach the Atlas cluster, likely due to IP restrictions.
Environment Variables: 
    src/config/env.js
Centralizes configuration management.
Loads variables from 
.env
.
Key Variables:
    MONGO_URI: Connection string for MongoDB.
    JWT_SECRET: Secret key for signing tokens.
3. Key Components
Models (src/models/)
    User.js
    : Defines the user schema (email, password hash, role, verification status).
    RefreshToken.js
    : Stores refresh tokens to allow users to stay logged in without re-entering passwords.
Routes & Controllers (src/routes/ & src/controllers/)
    The API endpoints are defined in authRoutes.js and implemented in authController.js:

    Endpoint	Method	Function	Description
    /register	POST	register    Creates a new user, hashes password, sends mock verification email.
    /login	    POST	login       Validates credentials, returns Access & Refresh tokens.
    /verify-email GET	verifyEmail Verifies user's email using a token.
    /refresh	POST	refreshToken Issues a new Access Token using a valid Refresh Token.
    /logout	    POST	logout      Revokes the Refresh Token.
    /me	        GET     getMe       Returns current user's profile (protected route).


Once the server starts successfully:

Open http://localhost:3002/api-docs to see the Swagger UI.


4. Security & Authorization

Role-Based Access Control (RBAC)
The system implements RBAC to manage user permissions.
- Roles:
    - candidate (Default)
    - recruiter
    - executive
    - admin
- Implementation:
    - The `User` model stores the `role`.
    - The `authMiddleware.restrictTo(...roles)` function protects routes based on these roles.
    - The Access Token (JWT) payload includes the user's `role`, allowing other microservices to make authorization decisions without querying the Auth Service database.
- Registration Note: Public registration should default to the 'candidate' role to prevent privilege escalation.

Secrets Management (JWT Configuration)
The service uses Asymmetric Encryption (RS256) for JSON Web Tokens.
- Keys:
    - `secrets/jwt_private.pem`: Private key used by Auth Service to SIGN tokens. MUST be kept secret.
    - `secrets/jwt_public.pem`: Public key used by Auth Service (and other services) to VERIFY tokens.
- Benefits:
    - Decouples authentication from verification.
    - Other microservices (e.g., Candidate Service) can validate tokens using the Public Key without needing a direct connection to the Auth Service or sharing a sensitive secret key.


####  REGISTRATION DATAFLOW   ####

Here is the detailed breakdown of the code execution path:

Step 1: The Request
    The user sends a POST request to http://localhost:3002/api/v1/auth/register with a JSON body:
        {
        "email": "jane@example.com",
        "password": "securePassword123",
        "name": "Jane Doe"
        }

Step 2: Routing (src/routes/authRoutes.js)

    The Express router sees the path /register and directs the request to the register function in src/controllers/authController.js

Step 3: The Controller Logic (src/controllers/authController.js)

    Inside exports.register, the following happens sequentially:

    Input Extraction:    const { email, password, name, role } = req.body;
        The code pulls the raw data from the request body.

    Duplicate Check:
    const existingUser = await User.findOne({ email });
    It asks MongoDB: "Is there already a user with this email?"

    If yes: Returns 400 Email already registered.
    If no: Continues.
Password Hashing (Security Critical):

    const salt = await bcrypt.genSalt(10);
    const passwordHash = await bcrypt.hash(password, salt);
Crucial: We NEVER store the plain password. We use bcrypt to turn "securePassword123" into a secure hash like $2b$10$EixZa....

Token Generation: It creates a random string to use for email verification.

const emailVerificationToken = crypto.randomBytes(32).toString('hex');
Database Insertion: It creates the new User document in MongoDB.

const user = await User.create({
    email,
    passwordHash, // Storing the HASH, not the password
    name,
    emailVerificationToken,
    status: 'pending' // Default status
});
Email Notification: It calls the mock email service to log the verification link to the console.

await sendVerificationEmail(user.email, emailVerificationToken);
Response: Finally, it sends a success response back to the user.

{
    "message": "Registration successful. Please verify your email.",
    "userId": "656e..."
}

The user is now created but cannot login yet because isEmailVerified is false.

User checks their email (or server logs in this case) for the link: http://localhost:3002/api/v1/auth/verify-email?token=...
User clicks the link (GET request).
Server finds the user with that specific token.
Server updates isEmailVerified = true and clears the token.
User can now Login

Email Verification Flow (When Link is Pressed):
This explains what happens when the user clicks http://localhost:3002/api/v1/auth/verify-email?token=....

Step 1: The Request
The browser sends a GET request to the server. The important part is the ?token=... query parameter at the end of the URL.

Step 2: Routing
The router directs GET /verify-email to authController.verifyEmail.

Step 3: Controller Logic (
verifyEmail
)
Token Extraction:

const { token } = req.query;
It grabs the token string from the URL.

User Lookup (The Key Step):

const user = await User.findOne({ emailVerificationToken: token });
It searches the database for a user who has this exact token stored in their emailVerificationToken field.

If no user found: Returns 400 Invalid or expired token. This prevents fake or reused tokens.
Status Update: If the user is found, we modify their document:

user.isEmailVerified = true;       // Mark as verified
user.emailVerificationToken = undefined; // DELETE the token (One-time use!)
user.status = 'active';            // Activate the account
Save to Database:

await user.save();
The changes are written back to MongoDB. The user is now officially verified.

Response: The server sends a JSON response (or could redirect to a frontend login page):

{ "message": "Email verified successfully. You can now login." }


Login Flow (/login)

Goal: Authenticate the user and issue secure tokens for accessing the system.

Step 1: The Request
User sends a POST request with email and password.
Step 2: Validation & Security Checks
User Lookup: Checks if the email exists in the database.
Password Check: Uses bcrypt to compare the provided password with the stored hash.
Verification Check: Crucial: It explicitly checks if (!user.isEmailVerified). If the user hasn't verified their email yet, login is blocked.
Step 3: Token Generation
Access Token: Generates a short-lived JWT (e.g., 15 mins) containing the user's ID and role. This is used for API requests.
Refresh Token: Generates a long-lived opaque token (random string).
Step 4: Session Management
The Refresh Token is saved to the database (RefreshToken collection) along with metadata:
expiresAt: Set to 7 days in the future.
ipAddress & userAgent: For security auditing (tracking where the login came from).
Updates the user's lastLoginAt timestamp.
Step 5: Response
Returns both tokens (accessToken, 
refreshToken
) and basic user info.

Refresh Token Flow (/refresh)

Goal: Get a new Access Token when the old one expires, without forcing the user to log in again.

Step 1: The Request
Client sends a POST request with the 
refreshToken
.
Step 2: Validation
Database Lookup: Finds the refresh token in the database.
Security Checks: It fails if the token is:
Not found.
Revoked (already used or cancelled).
Expired (older than 7 days).
Step 3: Token Rotation (Security Best Practice)
The server does not just give back an access token. It performs Rotation:
Revokes the old refresh token (marks revoked = true).
Generates a completely new refresh token.
Saves the new token to the DB.
Why? If a refresh token is stolen, it can only be used once. If the thief tries to use it again, it will fail (because it's revoked), alerting the system.
Step 4: Response
Returns a new accessToken and the new 
refreshToken
.

Logout Flow (/logout)

Goal: Securely end the session.

Step 1: The Request
Client sends a POST request with the 
refreshToken
 they want to invalidate.
Step 2: Revocation
The server finds that specific token in the database and sets revoked: true.
Result: That specific refresh token can no longer be used to generate new access tokens. Even if the user still has the token string, it is useless.

Get Current User (/me)
Goal: Retrieve the profile of the currently logged-in user.

Step 1: The Request
Client sends a GET request.
Prerequisite: This route is "protected". The request must have a valid Access Token in the Authorization header (handled by middleware before reaching this controller).
Step 2: Identification
The middleware decodes the token and attaches the user ID to req.user.sub.
Step 3: Data Retrieval
The controller finds the user by ID: User.findById(req.user.sub).
Filtering: It explicitly excludes sensitive data using .select('-passwordHash') so the password hash is never sent to the client.
Step 4: Response
Returns the user object (Name, Email, Role, ID).